### 1 数组

滑动窗口法的思路：快指针逐步移动遍历整个数组。在此过程中，快指针每移动一步，都调整慢指针的位置到合适位置，再进行快指针的移动。伪代码大致如下：

```c++
int ans = 0; //题目所求内容
int slow = 0, fast = 0;
for(fast<len; fast++){
    //调整slow的位置
    while(条件){
	//move slow，一般是slow++
    }
    //根据逻辑更新ans，一般是ans=max(ans, ...)之类的
}
```

### 2 链表

#### 2.1 虚拟头节点

一个常见的技巧是创建一个虚拟头节点dummy，指向真正的头节点head。这样做的好处是：

- 统一了头节点和其他节点的操作：因为头节点本身没有前置节点，在操作时经常需要与其他节点分类讨论。加入dummy后省去了分类讨论的工作
- 需要得到头节点时返回 `dummy->next`即可

```c++
ListNode* dummy = new ListNode();
dummy->next = head;
```

#### 2.2 画图分析链表指向的移动

在分析链表指向的移动操作时一定要画图，每次对局部的操作通过画图明确谁和谁连线，以及各操作的顺序。因为链表的操作一般是重复性的过程，所以把局部的操作画图明确后，其他操作都是重复的。

#### 2.3 防止对nullptr操作

链表操作最重要的判断就是防止操作对象为nullptr。防止位空的判断一般是在while循环的出循环条件里。判断为空的原则是“语句中操作了谁，就要保证谁为非空”。举例如下：

```c++
while(nodeA!=nullptr && nodeB!=nullptr && nodeB->next!=nullptr){
    nodeA = nodeA->next;  // 这里访问了nodeA的next变量，需要保证nodeA为非空
    nodeB = nodeB->next->next; // 这里需要保证ndoeB和nodeB->next都为非空
}
```

### 3 双指针法

双指针法不局限于具体的数据结构，在数组、字符串等类型中都有可能出现。

双指针法的本质是将O(n2)的遍历工作，通过以两个指针的移动作为替代，将复杂度降为O(n)。其普遍的代码思路为一个while循环，重点在于while循环内部对于每次移动的（只作粗略启发，具体需要依题意而定制）：

```cpp
while(left < right){
    // while中定义的是每一步的操作
    // 通常为if-else if-else，定义每一步如何移动left和right
}
```
